<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="color-scheme" content="dark light"/>
<title>Time · Illumina v6 — Time as a Living Derivative</title>
<meta name="description" content="A visual-mathematical manifesto bridging Smolin-style realism with a living, derivative view of time. Canvas2D + WebAudio. 128 Hz base. Violet-pearl aesthetic.">
<style>
  :root{
    --bg-0:#0c0912;
    --bg-1:#130f1e;
    --violet-1:#a78bfa;
    --violet-2:#c4b5fd;
    --violet-3:#e9d5ff;
    --pearl-1:#f8fafc;
    --pearl-2:#e2e8f0;
    --teal:#67e8f9;
    --amber:#fcd34d;
    --glass-rgba:255,255,255;
  }
  html,body{height:100%;margin:0}
  body{
    background: radial-gradient(1200px 800px at 15% 10%, rgba(167,139,250,0.10), transparent 60%),
                radial-gradient(1000px 1000px at 85% 20%, rgba(236,72,153,0.08), transparent 60%),
                linear-gradient(180deg, var(--bg-0), var(--bg-1));
    color: #eef;
    font: 15px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    letter-spacing:.15px;
  }
  .wrap{max-width:1120px;margin:0 auto;padding:24px}
  .title{
    display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin:20px 0 14px;
  }
  .glyph{width:44px;height:44px;border-radius:12px;
    background: conic-gradient(from 210deg, rgba(167,139,250,.35), rgba(103,232,249,.28), rgba(252,211,77,.25), transparent 70%);
    box-shadow: 0 0 40px rgba(167,139,250,.3), inset 0 0 24px rgba(255,255,255,.05);
  }
  h1{font: 800 28px/1.15 ui-sans-serif; margin:0}
  .tag{opacity:.8;font-size:13px}
  .glass{
    background: linear-gradient(180deg, rgba(var(--glass-rgba),.06), rgba(255,255,255,.02));
    border: 1px solid rgba(255,255,255,.12);
    border-radius:16px; padding:18px 18px 14px; backdrop-filter: blur(10px);
    box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.05);
  }
  .grid{display:grid;grid-template-columns:1.2fr .8fr; gap:18px}
  @media (max-width:900px){ .grid{grid-template-columns:1fr} }
  h2{font:700 18px/1.25 ui-sans-serif; margin:0 0 8px}
  h3{font:700 15px/1.3; margin:14px 0 6px}
  p{margin:8px 0 6px; color:#e9e7ff}
  .note{font-size:13px; opacity:.8}
  .kbd{display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06)}
  .pill{
    display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.12); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
    font-size:13px; margin:2px 6px 8px 0;
  }
  .accent{color:var(--violet-2)}
  .controls{display:grid; grid-template-columns:repeat(2,1fr); gap:10px; margin:10px 0}
  @media (max-width:700px){ .controls{grid-template-columns:1fr} }
  label{font-size:13px; opacity:.9; display:block; margin:0 0 4px}
  input[type="range"]{width:100%}
  button{
    appearance:none; border:1px solid rgba(255,255,255,.2); background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
    color:#fff; border-radius:10px; padding:10px 14px; font-weight:700; letter-spacing:.2px; cursor:pointer;
  }
  button:focus{outline:2px solid var(--violet-2); outline-offset:2px}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  canvas{width:100%; height:420px; display:block; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); border:1px solid rgba(255,255,255,.12)}
  .eq{
    font: 700 15px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:10px 12px; color:#f5f3ff;
    min-height:45px; display:flex; align-items:center; justify-content:center; text-align:center;
    box-shadow: inset 0 0 30px rgba(167,139,250,.06);
  }
  .badge{font-size:12px; opacity:.8; padding:2px 6px; border:1px solid rgba(255,255,255,.18); border-radius:999px}
  footer{opacity:.8; font-size:12px; margin:18px 0 40px}
  /* reduced motion */
  @media (prefers-reduced-motion: reduce){
    .soft-anim{transition:none; animation:none}
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="title">
    <div class="glyph" aria-hidden="true"></div>
    <div>
      <h1>Time as a Living Derivative</h1>
      <div class="tag">Illumina v6 · violet-pearl · <span class="accent">128 Hz</span> base · Canvas2D + WebAudio</div>
    </div>
    <span class="pill" aria-hidden="true">realism</span>
    <span class="pill" aria-hidden="true">derivative time</span>
    <span class="pill" aria-hidden="true">cultural harmonics</span>
  </div>

  <div class="grid" role="region" aria-label="Paper and Controls">

    <!-- LEFT: PAPER TEXT + EQUATIONS -->
    <section class="glass" aria-label="Paper">
      <h2>Abstract — The Pulse of Becoming</h2>
      <p>
        We propose that <em>time is not a background parameter</em> but an <strong>active derivative field</strong> linking energy and distance.
        In a realist spirit (Smolin), we treat laws as historically evolving; the rate of this evolution couples to an effective temporal curvature
        \(\tau_{\mathrm{eff}}\). We present a minimal dimensional ansatz, simulations of an <em>E–x</em> field, and an audible mapping at 128 Hz for
        human-perceptual inspection.
      </p>

      <h3>Foundations of Realism (Smolin Bridge)</h3>
      <p class="note">
        If time is fundamental and laws evolve, any adequate theory should expose <em>rates</em> of change of the structures those laws constrain.
        Here we hypothesize the relevant rate appears as derivatives of energy with respect to distance, properly scaled by \(c^3\).
      </p>

      <h3>Derivative Model (Dimensional Skeleton)</h3>
      <div class="eq" id="eqBox" aria-live="polite" aria-label="Animated equation">
        <!-- animated text inserts here -->
      </div>
      <p>
        We explore a cluster of relations—not as final identities, but as a <em>derivative atlas</em>:
      </p>
      <div class="eq" aria-hidden="true" style="margin-top:8px">
        τ₀ := E / c³   ;   ∂τ/∂x ≈ (∂E/∂x)/c³   ;   τ̈ ↔ ∂²E/∂x² · (1/c³)
      </div>
      <p class="note">
        <strong>Dimensional check:</strong> \([E]=\mathrm{kg\,m^2\,s^{-2}}\), \([c^3]=\mathrm{m^3\,s^{-3}}\).
        Thus \(E/c^3 \sim \mathrm{kg/m}\). This “line-mass-like” dimension signals τ here is not a clock reading but an <em>effective temporal density</em>
        that curves histories where energy is concentrated and spatially structured.
      </p>

      <h3>Cultural Harmonics (Phenomenology)</h3>
      <p>
        Choruses, electoral cycles, and rumor waves behave as macroscopic interference patterns in the \(\tau\) field:
        where \(\partial^2 E/\partial x^2\) spikes, <em>attention accelerates</em>. We sonify this by modulating a 128 Hz tone with τ̈.
      </p>

      <h3>Notes to Lee Smolin</h3>
      <p class="note">
        This is an invitation to critique the skeleton above: under what constraints on \(E(x)\) (e.g., locality, causal structure) can a τ-like
        quantity be promoted to dynamics without contradiction? Which histories prefer evolving-law interpretations?
      </p>
    </section>

    <!-- RIGHT: CONTROLS + SIM -->
    <aside class="glass" aria-label="Controls">
      <h2>Instrument Panel</h2>
      <div class="row" role="group" aria-label="Audio controls">
        <button id="startAudio" aria-pressed="false" aria-label="Enable sound (iOS safe)">Enable Audio (128 Hz)</button>
        <span class="badge">A11y: <span class="kbd">Space</span> toggles</span>
      </div>

      <div class="controls" role="group" aria-label="Parameters">
        <div>
          <label for="vol">Volume</label>
          <input id="vol" type="range" min="0" max="1" step="0.001" value="0.12" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.12"/>
        </div>
        <div>
          <label for="tauAccel">τ̈ (law-change acceleration)</label>
          <input id="tauAccel" type="range" min="0" max="1" step="0.001" value="0.25" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0.25"/>
        </div>
      </div>

      <h3>Experimental Sketch</h3>
      <p class="note">
        Canvas shows an <em>E(x,y)</em> texture; hue encodes \(\partial \tau/\partial x\), brightness encodes \(\partial^2 E/\partial x^2\).
        Moving τ̈ animates curvature &amp; the 128 Hz tone’s gentle FM/AM.
      </p>
      <canvas id="field" width="900" height="420" role="img" aria-label="Derivative field visualization"></canvas>
    </aside>

  </div>

  <section class="glass" style="margin-top:18px" aria-label="Appendix">
    <h2>Appendix — Implementation Notes</h2>
    <p class="note">
      Audio: single OscillatorNode (sine) at 128 Hz; GainNode for volume; modulation depth maps from τ̈.  
      Visuals: pseudo-energy field \(E(x,y) = \sum_i A_i \exp(-r_i^2/\sigma_i^2)\) with drifting centers; derivatives estimated analytically and by finite differences for color.
    </p>
    <p class="note">Keyboard: <span class="kbd">Space</span> toggle audio, <span class="kbd">←/→</span> adjust τ̈, <span class="kbd">↓/↑</span> adjust volume.</p>
  </section>

  <footer>
    © Illumina v6 · “Time as a Living Derivative”. Single-file. No external calls. Works offline after first load.
  </footer>
</div>

<script>
(() => {
  // ===== Accessibility & State =====
  const qs = s => document.querySelector(s);
  const startBtn = qs('#startAudio');
  const vol = qs('#vol');
  const tauAccel = qs('#tauAccel');
  const eqBox = qs('#eqBox');

  // ===== Animated Equation (gentle morph) =====
  const eqFrames = [
    "τ₀ := E / c³",
    "∂τ/∂x ≈ (∂E/∂x) / c³",
    "τ̈ ↔ (∂²E/∂x²) · (1/c³)",
    "τ_eff ≈ { E, ∂E/∂x, ∂²E/∂x² } / c³"
  ];
  let eqIndex = 0, eqTick = 0, eqPhase = "type";
  function animateEq(){
    const target = eqFrames[eqIndex];
    const t = 32; // typing speed (ms per char)
    if(eqPhase === "type"){
      const n = Math.min(target.length, Math.floor(eqTick / t));
      eqBox.textContent = target.slice(0,n) + (n<target.length ? "▉" : "");
      eqTick += 16;
      if(n >= target.length){ eqPhase = "hold"; eqTick = 0; }
    }else if(eqPhase === "hold"){
      eqTick += 16;
      eqBox.textContent = target;
      if(eqTick > 1500){ eqPhase = "erase"; eqTick = 0; }
    }else{ // erase
      const n = Math.max(0, target.length - Math.floor(eqTick / t));
      eqBox.textContent = target.slice(0,n) + " ";
      eqTick += 16;
      if(n <= 0){ eqPhase = "type"; eqTick = 0; eqIndex = (eqIndex+1)%eqFrames.length; }
    }
    requestAnimationFrame(animateEq);
  }
  animateEq();

  // ===== Audio Engine (128 Hz base) =====
  let actx, master, osc, fmOsc, fmGain;
  let audioOn = false;
  function setupAudio(){
    if(actx) return;
    actx = new (window.AudioContext || window.webkitAudioContext)();
    master = actx.createGain(); master.gain.value = parseFloat(vol.value);
    // Carrier
    osc = actx.createOscillator();
    osc.type = "sine"; osc.frequency.value = 128.0;
    // FM: map tauAccel to gentle modulation 0–3 Hz
    fmOsc = actx.createOscillator(); fmOsc.type = "sine";
    fmGain = actx.createGain();
    fmGain.gain.value = 0; // set dynamically
    fmOsc.connect(fmGain).connect(osc.frequency);
    osc.connect(master).connect(actx.destination);
    fmOsc.start();
    osc.start();
  }
  function updateAudio(){
    if(!actx) return;
    master.gain.value = parseFloat(vol.value);
    // map τ̈ ∈ [0,1] → fmRate ∈ [0.1, 3.2] Hz and fmDepth ∈ [0, 7] Hz
    const tacc = parseFloat(tauAccel.value);
    const fmRate = 0.1 + tacc * 3.1;
    const fmDepth = tacc * 7.0;
    fmOsc.frequency.setTargetAtTime(fmRate, actx.currentTime, 0.05);
    fmGain.gain.setTargetAtTime(fmDepth, actx.currentTime, 0.05);
  }
  function toggleAudio(){
    if(!actx) setupAudio();
    if(actx.state === "suspended"){ actx.resume(); }
    audioOn = !audioOn;
    master.gain.value = audioOn ? parseFloat(vol.value) : 0.0;
    startBtn.setAttribute("aria-pressed", audioOn ? "true" : "false");
    startBtn.textContent = audioOn ? "Audio: ON (128 Hz)" : "Enable Audio (128 Hz)";
  }
  startBtn.addEventListener('click', () => { toggleAudio(); updateAudio(); });
  vol.addEventListener('input', updateAudio);
  tauAccel.addEventListener('input', updateAudio);

  // Keyboard controls
  window.addEventListener('keydown', (e) => {
    if(e.code === 'Space'){ e.preventDefault(); toggleAudio(); updateAudio(); }
    if(e.key === 'ArrowRight'){ e.preventDefault(); tauAccel.value = Math.min(1, parseFloat(tauAccel.value)+0.02).toFixed(3); tauAccel.dispatchEvent(new Event('input')); }
    if(e.key === 'ArrowLeft'){ e.preventDefault(); tauAccel.value = Math.max(0, parseFloat(tauAccel.value)-0.02).toFixed(3); tauAccel.dispatchEvent(new Event('input')); }
    if(e.key === 'ArrowUp'){ e.preventDefault(); vol.value = Math.min(1, parseFloat(vol.value)+0.02).toFixed(3); vol.dispatchEvent(new Event('input')); }
    if(e.key === 'ArrowDown'){ e.preventDefault(); vol.value = Math.max(0, parseFloat(vol.value)-0.02).toFixed(3); vol.dispatchEvent(new Event('input')); }
  });

  // iOS unlock: also bind to first pointer
  window.addEventListener('pointerdown', () => {
    if(actx && actx.state === 'suspended'){ actx.resume(); }
  }, {once:false});

  // ===== Canvas Field =====
  const canvas = qs('#field');
  const ctx = canvas.getContext('2d', {alpha:false});
  let t = 0;

  // Define drifting energy lumps (gaussians)
  const lumps = Array.from({length: 6}).map((_,i) => ({
    A: 0.8 + 1.2*Math.random(),
    x: 100 + Math.random()*(canvas.width-200),
    y: 80 + Math.random()*(canvas.height-160),
    vx: (Math.random()*2-1)*0.25,
    vy: (Math.random()*2-1)*0.25,
    s: 60 + Math.random()*100
  }));

  function stepLumps(){
    const w = canvas.width, h = canvas.height;
    for(const L of lumps){
      L.x += L.vx; L.y += L.vy;
      if(L.x < 60 || L.x > w-60) L.vx *= -1;
      if(L.y < 60 || L.y > h-60) L.vy *= -1;
    }
  }

  function render(){
    stepLumps();
    const w = canvas.width, h = canvas.height;
    const img = ctx.createImageData(w, h);
    const data = img.data;
    const tacc = parseFloat(tauAccel.value);

    // precompute for speed: energy and derivatives (finite diff in x)
    function energyAt(x, y){
      let E=0;
      for(const L of lumps){
        const dx = x - L.x, dy = y - L.y;
        const r2 = dx*dx + dy*dy;
        E += L.A * Math.exp(-r2/(L.s*L.s));
      }
      return E;
    }

    // sample grid
    for(let y=0; y<h; y++){
      // simple cache row for ex
      let prev = energyAt(0, y);
      let curr = energyAt(1, y);
      for(let x=0; x<w; x++){
        const next = (x+1<w) ? energyAt(x+1, y) : curr;
        const E = curr;
        const dEx = next - prev;           // ∂E/∂x (centered approx)
        const ddEx = next - 2*curr + prev; // ∂²E/∂x²
        prev = curr; curr = next;

        // Map to visual:
        // hue from ∂τ/∂x ≈ (∂E/∂x)/c³ (ignore constant scale) → tanh compress
        const hu = 200 + 100 * Math.tanh(dEx * 3.0);
        // brightness from curvature ddEx; add τ̈ drive
        const br = Math.min(1, Math.abs(ddEx)*8.0 + 0.1 + tacc*0.25);
        // saturation pulsed by time
        const sat = 0.55 + 0.35*Math.sin( (t*0.002) + (x+y)*0.0008 );

        // convert HSL to RGB
        const c = hsl2rgb(hu/360, sat, 0.12 + 0.65*br);
        const idx = (y*w + x)*4;
        data[idx]   = c[0];
        data[idx+1] = c[1];
        data[idx+2] = c[2];
        data[idx+3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);

    // overlay subtle gridlines / labels
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;
    for(let gx=0; gx<w; gx+=90){ ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,h); ctx.stroke(); }
    for(let gy=0; gy<h; gy+=90){ ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(w,gy); ctx.stroke(); }

    // caption
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "700 12px ui-monospace, monospace";
    ctx.fillText("hue ≈ ∂τ/∂x, brightness ≈ ∂²E/∂x², 128 Hz ⇄ τ̈ (FM/AM)", 10, h-12);

    t += 16;
    requestAnimationFrame(render);
  }
  function hsl2rgb(h, s, l){
    let r, g, b;
    if(s === 0){ r = g = b = l; }
    else{
      const hue2rgb = (p, q, t) => {
        if(t<0) t+=1; if(t>1) t-=1;
        if(t<1/6) return p + (q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p + (q-p)*(2/3 - t)*6;
        return p;
      };
      const q = l < 0.5 ? l*(1+s) : l + s - l*s;
      const p = 2*l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [(r*255)|0, (g*255)|0, (b*255)|0];
  }
  render();

  // ===== Inline Service Worker for offline =====
  if('serviceWorker' in navigator){
    const swCode = `
      self.addEventListener('install', e => {
        e.waitUntil((async ()=>{
          const c = await caches.open('time-v6');
          await c.addAll(['./']);
        })());
      });
      self.addEventListener('fetch', e => {
        e.respondWith((async ()=>{
          const r = await caches.match(e.request);
          return r || fetch(e.request);
        })());
      });
    `;
    const blob = new Blob([swCode], {type:'text/javascript'});
    const swURL = URL.createObjectURL(blob);
    navigator.serviceWorker.register(swURL);
  }
})();
</script>
</body>
</html>
