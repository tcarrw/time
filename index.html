<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="color-scheme" content="dark light"/>
<title>Time · Illumina v6 — Living Derivative (Back-Channel Audio)</title>
<meta name="description" content="Smolin-bridge sketch. Violet-pearl. Robust audio: Oscillator → BufferSource → HTMLAudio WAV fallback. 160 Hz base. Canvas2D + WebAudio.">
<style>
  :root{ --bg0:#0c0912; --bg1:#130f1e; --vio:#c4b5fd; }
  html,body{height:100%;margin:0}
  body{
    background:
      radial-gradient(1200px 800px at 15% 10%, rgba(167,139,250,0.10), transparent 60%),
      radial-gradient(1000px 1000px at 85% 20%, rgba(236,72,153,0.08), transparent 60%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    color:#eef; font:15px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
  }
  .wrap{max-width:1120px;margin:0 auto;padding:24px}
  h1{margin:8px 0 4px;font:800 28px/1.15 ui-sans-serif}
  .glass{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:18px 18px 14px;backdrop-filter:blur(10px)}
  .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:18px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
  h2{font:700 18px/1.25 ui-sans-serif;margin:0 0 8px}
  h3{font:700 15px/1.3;margin:14px 0 6px}
  p{margin:8px 0 6px;color:#e9e7ff}
  .eq{font:700 15px/1.35 ui-monospace,monospace;background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.15);border-radius:10px;padding:10px 12px;color:#f5f3ff;min-height:45px;display:flex;align-items:center;justify-content:center;text-align:center}
  .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin:10px 0}
  @media (max-width:700px){.controls{grid-template-columns:1fr}}
  label{font-size:13px;opacity:.9;display:block;margin:0 0 4px}
  input[type="range"]{width:100%}
  button{appearance:none;border:1px solid rgba(255,255,255,.2);
    background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.06));
    color:#fff;border-radius:10px;padding:10px 14px;font-weight:700;letter-spacing:.2px;cursor:pointer}
  button:focus{outline:2px solid var(--vio);outline-offset:2px}
  canvas{width:100%;height:420px;display:block;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid rgba(255,255,255,.12)}
  .mini{font:12px/1.4 ui-monospace,monospace;opacity:.85}
  .chip{display:inline-block;margin-left:8px;padding:2px 8px;border:1px solid rgba(255,255,255,.25);border-radius:999px}
  .ok{color:#9affb0}.bad{color:#ff9a9a}
</style>
</head>
<body>
<div class="wrap">
  <h1>Time as a Living Derivative</h1>
  <div class="grid">
    <section class="glass">
      <h2>Abstract — The Pulse of Becoming</h2>
      <p>Time as an <b>active derivative field</b> linking energy and distance. We sketch a τ-atlas and sonify τ̈ at <b>160 Hz</b>.
      Violet-pearl aesthetic; Smolin realism bridge.</p>
      <h3>Derivative Model (Dimensional Skeleton)</h3>
      <div class="eq" id="eqBox"></div>
      <p class="mini">Dimensional note: E/c³ ~ kg/m → treat τ here as an effective temporal density/curvature proxy rather than a clock.</p>
      <h3>Cultural Harmonics</h3>
      <p>Hue = arg(∇E), saturation = |∇E|, brightness = ∇²E; τ̈ controls gentle FM.</p>
    </section>

    <aside class="glass">
      <h2>Instrument Panel
        <span class="chip mini" id="engine">engine: —</span>
        <span class="chip mini" id="audioState">audio: off</span>
      </h2>
      <button id="startAudio" aria-pressed="false" aria-label="Enable sound">Enable Audio (160 Hz)</button>
      <div class="controls">
        <div>
          <label for="vol">Volume</label>
          <input id="vol" type="range" min="0" max="1" step="0.001" value="0.35"/>
        </div>
        <div>
          <label for="tauAccel">τ̈ (law-change acceleration)</label>
          <input id="tauAccel" type="range" min="0" max="1" step="0.001" value="0.35"/>
        </div>
      </div>
      <canvas id="field" width="720" height="380" role="img" aria-label="Derivative field visualization"></canvas>
      <div class="mini" id="selfcheck">fps <span>—</span></div>
    </aside>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const eqBox=$('#eqBox'), startBtn=$('#startAudio'), vol=$('#vol'), tauAccel=$('#tauAccel');
  const canvas=$('#field'), ctx=canvas.getContext('2d',{alpha:false});
  const chipEngine=$('#engine'), chipAudio=$('#audioState'), fpsEl=$('#selfcheck').querySelector('span');

  // === Animated equation
  const frames=["τ₀ := E / c³","∇τ ≈ (∇E)/c³","τ̈ ↔ (∂²E/∂x² + ∂²E/∂y²)/c³","τ_eff ≈ {E, ∇E, ∇²E}/c³"];
  let fi=0, ft=0, fp="type"; (function loopEq(){
    const s=frames[fi], spd=30;
    if(fp==="type"){ const n=Math.min(s.length,Math.floor(ft/spd)); eqBox.textContent=s.slice(0,n)+(n<s.length?"▉":""); ft+=16; if(n>=s.length){fp="hold";ft=0;} }
    else if(fp==="hold"){ ft+=16; eqBox.textContent=s; if(ft>1400){fp="erase";ft=0;} }
    else { const n=Math.max(0,s.length-Math.floor(ft/spd)); eqBox.textContent=s.slice(0,n)+" "; ft+=16; if(n<=0){fp="type";ft=0;fi=(fi+1)%frames.length;} }
    requestAnimationFrame(loopEq);
  })();

  // === AUDIO — 3-path back-channel
  const BASE = 160.0;
  let actx=null, master=null, audioOn=false, engine="—";
  // path A: oscillator
  let osc=null, fmOsc=null, fmGain=null;
  // path B: buffer source
  let bufSrc=null, fmTimer=null, buf=null;
  // path C: HTMLAudio (generated WAV)
  let wavEl=null, wavPlaying=false;

  function setEngine(label){ engine=label; chipEngine.textContent="engine: "+label; }
  function setAudioState(on){ chipAudio.textContent="audio: "+(on?"on":"off"); chipAudio.className="chip mini "+(on?"ok":"bad"); }

  function makeSineBuffer(ctx, freq=BASE, sec=1.0){
    const sr=ctx.sampleRate, len=Math.floor(sec*sr);
    const b=ctx.createBuffer(1,len,sr); const ch=b.getChannelData(0);
    for(let i=0;i<len;i++){ ch[i]=Math.sin(2*Math.PI*freq*(i/sr)); }
    return b;
  }
  function buildWavBlob(freq=BASE, sec=1.0){
    const sr=44100, len=Math.floor(sec*sr);
    const pcm=new Int16Array(len);
    for(let i=0;i<len;i++){ pcm[i]=Math.max(-1,Math.min(1,Math.sin(2*Math.PI*freq*(i/sr))))*32767; }
    const header=new ArrayBuffer(44), dv=new DataView(header);
    const bytes=pcm.length*2;
    // RIFF/WAVE header
    function w32(o,v){dv.setUint32(o,v,true)} function w16(o,v){dv.setUint16(o,v,true)}
    new Uint8Array(header).set([82,73,70,70]); w32(4,36+bytes); new Uint8Array(header,8,4).set([87,65,86,69]);
    new Uint8Array(header,12,4).set([102,109,116,32]); w32(16,16); w16(20,1); w16(22,1);
    w32(24,sr); w32(28,sr*2); w16(32,2); w16(34,16); new Uint8Array(header,36,4).set([100,97,116,97]); w32(40,bytes);
    return new Blob([header, new DataView(pcm.buffer)], {type:'audio/wav'});
  }

  function startOsc(){
    actx = new (window.AudioContext||window.webkitAudioContext)();
    master=actx.createGain(); master.gain.value=0.0;
    osc=actx.createOscillator(); osc.type="sine"; osc.frequency.value=BASE;
    fmOsc=actx.createOscillator(); fmOsc.type="sine"; fmGain=actx.createGain(); fmGain.gain.value=2.0; fmOsc.frequency.value=0.8;
    fmOsc.connect(fmGain).connect(osc.frequency); osc.connect(master).connect(actx.destination);
    osc.start(); fmOsc.start();
    setEngine("OSC");
  }
  function startBuffer(){
    if(!actx){ actx = new (window.AudioContext||window.webkitAudioContext)(); }
    master=master||actx.createGain(); master.gain.value=0.0; master.connect(actx.destination);
    buf = makeSineBuffer(actx, BASE, 1.0);
    bufSrc = actx.createBufferSource(); bufSrc.buffer=buf; bufSrc.loop=true; bufSrc.connect(master); bufSrc.start();
    // “FM” by modulating playbackRate (subtle)
    clearInterval(fmTimer); fmTimer=setInterval(()=>{
      const tacc=parseFloat(tauAccel.value);
      const rate = 1 + (tacc*0.03) * Math.sin(performance.now()/350);
      if(bufSrc) bufSrc.playbackRate.setValueAtTime(rate, actx.currentTime);
    }, 50);
    setEngine("BUF");
  }
  function startWav(){
    const blob = buildWavBlob(BASE, 1.0);
    wavEl = new Audio(); wavEl.src = URL.createObjectURL(blob); wavEl.loop = true; wavEl.volume = parseFloat(vol.value);
    // FM with playbackRate
    let fmInt = setInterval(()=>{
      const tacc=parseFloat(tauAccel.value);
      wavEl.playbackRate = 1 + (tacc*0.03) * Math.sin(performance.now()/350);
    }, 50);
    wavEl.onended = ()=>clearInterval(fmInt);
    wavEl.play().then(()=>{ wavPlaying=true; setEngine("WAV"); }).catch(()=>{});
  }

  function applyVolume(){
    const v=parseFloat(vol.value);
    if(master){ master.gain.setTargetAtTime(audioOn? v : 0.0, actx.currentTime, 0.03); }
    if(wavEl){ wavEl.volume = audioOn? v : 0.0; }
  }
  function applyFM(){
    const tacc=parseFloat(tauAccel.value);
    if(fmOsc && fmGain){
      fmOsc.frequency.setTargetAtTime(0.2 + tacc*3.4, actx.currentTime, 0.05);
      fmGain.gain.setTargetAtTime(2.0 + tacc*8.0, actx.currentTime, 0.05);
    }
    // buffer/wav FM handled by intervals above
  }

  startBtn.addEventListener('click', async () => {
    try{
      // Path A: Oscillator (inside gesture)
      startOsc();
      await actx.resume();
      audioOn = !audioOn;
      setAudioState(audioOn);
      applyVolume(); applyFM();

      // quick RMS probe; if too quiet, fall back
      setTimeout(async ()=>{
        try{
          const ana=actx.createAnalyser(); ana.fftSize=512;
          master && master.connect(ana);
          const data=new Uint8Array(ana.frequencyBinCount);
          ana.getByteTimeDomainData(data);
          const rms = Math.sqrt(data.reduce((s,v)=>{ const x=(v-128)/128; return s + x*x; },0)/data.length);
          if(rms < 0.015){ // likely muted by platform → fallback
            // stop osc
            if(osc) { try{osc.stop();}catch{} }
            if(fmOsc) { try{fmOsc.stop();}catch{} }
            osc=fmOsc=null;
            // Path B
            startBuffer(); await actx.resume(); applyVolume();
            setAudioState(audioOn);
            setTimeout(async ()=>{
              // re-probe; if still too quiet → Path C
              const ana2=actx.createAnalyser(); ana2.fftSize=512; master && master.connect(ana2);
              const d2=new Uint8Array(ana2.frequencyBinCount); ana2.getByteTimeDomainData(d2);
              const rms2 = Math.sqrt(d2.reduce((s,v)=>{ const x=(v-128)/128; return s + x*x; },0)/d2.length);
              if(rms2 < 0.015){
                // stop buffer
                if(bufSrc){ try{bufSrc.stop();}catch{} bufSrc=null; }
                // Path C (HTMLAudio)
                startWav(); applyVolume(); setAudioState(audioOn);
              }
            }, 300);
          }
        }catch{}
      }, 150);
    }catch(e){
      // hard fallback straight to WAV
      startWav(); audioOn = !audioOn; setAudioState(audioOn); applyVolume();
    }
  }, {passive:true});

  vol.addEventListener('input', ()=>{ applyVolume(); }, {passive:true});
  tauAccel.addEventListener('input', ()=>{ applyFM(); }, {passive:true});
  document.addEventListener('visibilitychange',()=>{ if(document.visibilityState==='visible' && actx && actx.state==='suspended'){ actx.resume(); }});

  // === Canvas (same as prior good version)
  const lumps = Array.from({length:6},()=>({
    A: 0.8 + 1.2*Math.random(),
    x: 80 + Math.random()*(canvas.width-160),
    y: 70 + Math.random()*(canvas.height-140),
    vx:(Math.random()*2-1)*0.28,
    vy:(Math.random()*2-1)*0.28,
    s: 60 + Math.random()*90
  }));
  function E(x,y){ let e=0; for(const L of lumps){ const dx=x-L.x, dy=y-L.y, r2=dx*dx+dy*dy, ss=L.s*L.s; e += L.A * Math.exp(-r2/ss); } return e; }
  function stepLumps(){ const w=canvas.width,h=canvas.height; for(const L of lumps){ L.x+=L.vx; L.y+=L.vy; if(L.x<60||L.x>w-60)L.vx*=-1; if(L.y<60||L.y>h-60)L.vy*=-1; } }
  let last=performance.now();
  (function render(){
    stepLumps();
    const w=canvas.width,h=canvas.height,img=ctx.createImageData(w,h),data=img.data,tacc=parseFloat(tauAccel.value);
    for(let y=1;y<h-1;y++){
      let ePrev=E(0,y), eCurr=E(1,y);
      for(let x=1;x<w-1;x++){
        const eNext=E(x+1,y), eUp=E(x,y-1), eDown=E(x,y+1);
        const dEx=(eNext-ePrev)*0.5, dEy=(eDown-eUp)*0.5;
        const lap=(E(x+1,y)+E(x-1,y)+eUp+eDown-4*eCurr);
        const ang=Math.atan2(dEy,dEx), hue=(ang/(2*Math.PI)+0.5)*360;
        const gmag=Math.min(1, Math.hypot(dEx,dEy)*6.0);
        const br=Math.max(0.06, Math.min(0.9, 0.12 + 0.22*Math.tanh(lap*5.0) + 0.18*tacc));
        const sat=0.35 + 0.55*gmag;
        const rgb=hsl2rgb(hue/360, sat, br); const i=(y*w+x)*4;
        data[i]=rgb[0]; data[i+1]=rgb[1]; data[i+2]=rgb[2]; data[i+3]=255;
        ePrev=eCurr; eCurr=eNext;
      }
    }
    ctx.putImageData(img,0,0);
    ctx.strokeStyle="rgba(255,255,255,0.05)";
    for(let gx=0;gx<canvas.width;gx+=90){ctx.beginPath();ctx.moveTo(gx,0);ctx.lineTo(gx,canvas.height);ctx.stroke();}
    for(let gy=0;gy<canvas.height;gy+=90){ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(canvas.width,gy);ctx.stroke();}
    ctx.fillStyle="rgba(255,255,255,0.9)"; ctx.font="700 12px ui-monospace,monospace";
    ctx.fillText("hue ≈ arg(∇E), sat ≈ |∇E|, bright ≈ ∇²E, base 160 Hz", 10, canvas.height-12);

    const now=performance.now(); const fps=1000/(now-last); last=now;
    fpsEl.textContent = (fps|0)+"fps";
    requestAnimationFrame(render);
  })();
  function hsl2rgb(h,s,l){
    let r,g,b;
    if(s===0){r=g=b=l;}
    else{
      const q = l < .5 ? l*(1+s) : l + s - l*s;
      const p = 2*l - q;
      const f=(p,q,t)=>{ if(t<0)t+=1;if(t>1)t-=1;
        if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q;
        if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; };
      r=f(p,q,h+1/3); g=f(p,q,h); b=f(p,q,h-1/3);
    }
    return [(r*255)|0,(g*255)|0,(b*255)|0];
  }
})();
</script>
</body>
</html>
